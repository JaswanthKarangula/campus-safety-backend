// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: customers.sql

package db

import (
	"context"
	"database/sql"
)

const addNewDrone = `-- name: AddNewDrone :one
INSERT INTO "Drones" (model, customer_id, status, last_active)
VALUES ($1,$2,$3, NOW())
    RETURNING drone_id, model, customer_id, status, last_active
`

type AddNewDroneParams struct {
	Model      string `json:"model"`
	CustomerID int64  `json:"customer_id"`
	Status     string `json:"status"`
}

func (q *Queries) AddNewDrone(ctx context.Context, arg AddNewDroneParams) (Drone, error) {
	row := q.db.QueryRowContext(ctx, addNewDrone, arg.Model, arg.CustomerID, arg.Status)
	var i Drone
	err := row.Scan(
		&i.DroneID,
		&i.Model,
		&i.CustomerID,
		&i.Status,
		&i.LastActive,
	)
	return i, err
}

const createCustomerIssue = `-- name: CreateCustomerIssue :one



WITH new_issue AS (
INSERT INTO "Issues" (description, status, comments)
VALUES ($1, 'New', '')
    RETURNING issue_id
    )
INSERT INTO "CustomerIssues" (customer_id, issue_id)
SELECT $2, issue_id
FROM new_issue
RETURNING customer_id, admin_id, issue_id
`

type CreateCustomerIssueParams struct {
	Description string `json:"description"`
	CustomerID  int64  `json:"customer_id"`
}

// Page number (0-based)
func (q *Queries) CreateCustomerIssue(ctx context.Context, arg CreateCustomerIssueParams) (CustomerIssue, error) {
	row := q.db.QueryRowContext(ctx, createCustomerIssue, arg.Description, arg.CustomerID)
	var i CustomerIssue
	err := row.Scan(&i.CustomerID, &i.AdminID, &i.IssueID)
	return i, err
}

const createNewCustomer = `-- name: CreateNewCustomer :one
WITH new_customer AS (
INSERT INTO "Users" (username, email, hashedpassword, role)
VALUES ($1, $2, $3, 'Customer')
    RETURNING user_id, username, email, hashedpassword, role, created_at
    )
INSERT INTO "Customers" (customer_id, customer_name, admin_id)
SELECT user_id, username, 1
FROM new_customer
    RETURNING customer_id, customer_name, admin_id, resource_usage
`

type CreateNewCustomerParams struct {
	Username       string `json:"username"`
	Email          string `json:"email"`
	Hashedpassword string `json:"hashedpassword"`
}

func (q *Queries) CreateNewCustomer(ctx context.Context, arg CreateNewCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createNewCustomer, arg.Username, arg.Email, arg.Hashedpassword)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.CustomerName,
		&i.AdminID,
		&i.ResourceUsage,
	)
	return i, err
}

const deleteDrone = `-- name: DeleteDrone :one
DELETE FROM "Drones"
WHERE drone_id = $1 RETURNING drone_id, model, customer_id, status, last_active
`

func (q *Queries) DeleteDrone(ctx context.Context, droneID int64) (Drone, error) {
	row := q.db.QueryRowContext(ctx, deleteDrone, droneID)
	var i Drone
	err := row.Scan(
		&i.DroneID,
		&i.Model,
		&i.CustomerID,
		&i.Status,
		&i.LastActive,
	)
	return i, err
}

const getAlertsCountsByPriority = `-- name: GetAlertsCountsByPriority :many
SELECT sda.detection_type_id, COUNT(*) as alert_count
FROM "SafetyDetectionAlerts" sda
         JOIN "Drones" d ON sda.drone_id = d.drone_id
         JOIN "Customers" c ON d.customer_id = c.customer_id
WHERE c.customer_id = $1
GROUP BY sda.detection_type_id
ORDER BY sda.detection_type_id
`

type GetAlertsCountsByPriorityRow struct {
	DetectionTypeID int64 `json:"detection_type_id"`
	AlertCount      int64 `json:"alert_count"`
}

func (q *Queries) GetAlertsCountsByPriority(ctx context.Context, customerID int64) ([]GetAlertsCountsByPriorityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlertsCountsByPriority, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAlertsCountsByPriorityRow{}
	for rows.Next() {
		var i GetAlertsCountsByPriorityRow
		if err := rows.Scan(&i.DetectionTypeID, &i.AlertCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActiveSecurityOfficers = `-- name: GetAllActiveSecurityOfficers :many
SELECT u.user_id, u.username, u.email, u.hashedpassword, u.role, u.created_at
FROM "Users" u
         JOIN "SecuritOfficers" so ON u.user_id = so.officer_id
         JOIN "SecurityOfficerSchedule" sch ON so.officer_id = sch.officer_id
         JOIN "Customers" c ON so.customer_id = c.customer_id
WHERE c.customer_id = $1
  AND sch.day = TO_CHAR(NOW(), 'Dy')
  AND sch.start_time <= TO_CHAR(NOW(), 'HH24:MI:SS')::time
  AND sch.end_time >= TO_CHAR(NOW(), 'HH24:MI:SS')::time
`

func (q *Queries) GetAllActiveSecurityOfficers(ctx context.Context, customerID int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveSecurityOfficers, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.Hashedpassword,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAlerts = `-- name: GetAllAlerts :one
SELECT sda.alert_id, sda.timestamp, sda.frame_id, sda.drone_id, sda.stream_id, sda.detection_type_id, sda.description, sda.status
FROM "SafetyDetectionAlerts" sda
         JOIN "Drones" d ON sda.drone_id = d.drone_id
         JOIN "Customers" c ON d.customer_id = c.customer_id
WHERE c.customer_id = $1
`

func (q *Queries) GetAllAlerts(ctx context.Context, customerID int64) (SafetyDetectionAlert, error) {
	row := q.db.QueryRowContext(ctx, getAllAlerts, customerID)
	var i SafetyDetectionAlert
	err := row.Scan(
		&i.AlertID,
		&i.Timestamp,
		&i.FrameID,
		&i.DroneID,
		&i.StreamID,
		&i.DetectionTypeID,
		&i.Description,
		&i.Status,
	)
	return i, err
}

const getAllDronesByCustomer = `-- name: GetAllDronesByCustomer :many
SELECT d.drone_id, d.model, d.customer_id, d.status, d.last_active
FROM "Drones" d
         JOIN "Customers" c ON d.customer_id = c.customer_id
WHERE c.customer_id = $1
`

func (q *Queries) GetAllDronesByCustomer(ctx context.Context, customerID int64) ([]Drone, error) {
	rows, err := q.db.QueryContext(ctx, getAllDronesByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Drone{}
	for rows.Next() {
		var i Drone
		if err := rows.Scan(
			&i.DroneID,
			&i.Model,
			&i.CustomerID,
			&i.Status,
			&i.LastActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIssuesByCustomer = `-- name: GetAllIssuesByCustomer :many

SELECT i.issue_id, i.description, i.status, i.comments, i.created_at
FROM "Issues" i
         JOIN "CustomerIssues" ci ON i.issue_id = ci.issue_id
         JOIN "Customers" c ON ci.customer_id = c.customer_id
WHERE c.customer_id = $1
ORDER BY
    CASE
        WHEN i.status = 'New' THEN 1
        WHEN i.status = 'Pending' THEN 2
        WHEN i.status = 'Resolved' THEN 3
        ELSE 4
        END,
    i.created_at
    LIMIT $3 -- Number of issues per page
OFFSET $2
`

type GetAllIssuesByCustomerParams struct {
	CustomerID int64 `json:"customer_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

// Page number (0-based)
func (q *Queries) GetAllIssuesByCustomer(ctx context.Context, arg GetAllIssuesByCustomerParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, getAllIssuesByCustomer, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.IssueID,
			&i.Description,
			&i.Status,
			&i.Comments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOfficerIssues = `-- name: GetAllOfficerIssues :many
SELECT i.issue_id, i.description, i.status, i.comments, i.created_at
FROM "Issues" i
         JOIN "SecurityOfficerIssues" soi ON i.issue_id = soi.issue_id
         JOIN "SecuritOfficers" so ON soi.officer_id = so.officer_id
         JOIN "Customers" c ON so.customer_id = c.customer_id
WHERE c.customer_id = $1
ORDER BY
    CASE
        WHEN i.status = 'New' THEN 1
        WHEN i.status = 'Pending' THEN 2
        WHEN i.status = 'Resolved' THEN 3
        ELSE 4
        END,
    i.created_at
    LIMIT $3 -- Number of issues per page
OFFSET $2
`

type GetAllOfficerIssuesParams struct {
	CustomerID int64 `json:"customer_id"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) GetAllOfficerIssues(ctx context.Context, arg GetAllOfficerIssuesParams) ([]Issue, error) {
	rows, err := q.db.QueryContext(ctx, getAllOfficerIssues, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.IssueID,
			&i.Description,
			&i.Status,
			&i.Comments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnResolvedAlertsByDetectionType = `-- name: GetAllUnResolvedAlertsByDetectionType :many
SELECT sda.alert_id, sda.timestamp, sda.frame_id, sda.drone_id, sda.stream_id, sda.detection_type_id, sda.description, sda.status
FROM "SafetyDetectionAlerts" sda
         JOIN "Drones" d ON sda.drone_id = d.drone_id
         JOIN "Customers" c ON d.customer_id = c.customer_id
WHERE c.customer_id = $1 AND sda.detection_type_id = $2
`

type GetAllUnResolvedAlertsByDetectionTypeParams struct {
	CustomerID      int64 `json:"customer_id"`
	DetectionTypeID int64 `json:"detection_type_id"`
}

func (q *Queries) GetAllUnResolvedAlertsByDetectionType(ctx context.Context, arg GetAllUnResolvedAlertsByDetectionTypeParams) ([]SafetyDetectionAlert, error) {
	rows, err := q.db.QueryContext(ctx, getAllUnResolvedAlertsByDetectionType, arg.CustomerID, arg.DetectionTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SafetyDetectionAlert{}
	for rows.Next() {
		var i SafetyDetectionAlert
		if err := rows.Scan(
			&i.AlertID,
			&i.Timestamp,
			&i.FrameID,
			&i.DroneID,
			&i.StreamID,
			&i.DetectionTypeID,
			&i.Description,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnResolvedAlertsCountsByPriority = `-- name: GetUnResolvedAlertsCountsByPriority :many
SELECT sda.detection_type_id, COUNT(*) as alert_count
FROM "SafetyDetectionAlerts" sda
         JOIN "Drones" d ON sda.drone_id = d.drone_id
         JOIN "Customers" c ON d.customer_id = c.customer_id
WHERE c.customer_id = $1 AND sda.status != 'resolved'
GROUP BY sda.detection_type_id
ORDER BY sda.detection_type_id
`

type GetUnResolvedAlertsCountsByPriorityRow struct {
	DetectionTypeID int64 `json:"detection_type_id"`
	AlertCount      int64 `json:"alert_count"`
}

func (q *Queries) GetUnResolvedAlertsCountsByPriority(ctx context.Context, customerID int64) ([]GetUnResolvedAlertsCountsByPriorityRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnResolvedAlertsCountsByPriority, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnResolvedAlertsCountsByPriorityRow{}
	for rows.Next() {
		var i GetUnResolvedAlertsCountsByPriorityRow
		if err := rows.Scan(&i.DetectionTypeID, &i.AlertCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stopDroneStream = `-- name: StopDroneStream :one
UPDATE "Feeds"
SET status = 'inactive'
WHERE drone_id = $1 and stream_id=$2 RETURNING stream_id, drone_id, status
`

type StopDroneStreamParams struct {
	DroneID  sql.NullInt64 `json:"drone_id"`
	StreamID int64         `json:"stream_id"`
}

func (q *Queries) StopDroneStream(ctx context.Context, arg StopDroneStreamParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, stopDroneStream, arg.DroneID, arg.StreamID)
	var i Feed
	err := row.Scan(&i.StreamID, &i.DroneID, &i.Status)
	return i, err
}
